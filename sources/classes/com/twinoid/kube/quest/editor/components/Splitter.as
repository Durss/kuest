package com.twinoid.kube.quest.editor.components {	import com.twinoid.kube.quest.editor.components.window.BackWindow;	import com.twinoid.kube.quest.editor.vo.SplitterType;	import flash.events.Event;	/**	 * 	 * @author  Francois	 */	public class Splitter extends BackWindow {		private var _splitterType:String;								/* *********** *		 * CONSTRUCTOR *		 * *********** */		/**		 * Creates an instance of <code>Splitter</code>.		 */		public function Splitter(splitterType:String = null) {			_splitterType = (splitterType == null)? SplitterType.VERTICAL : splitterType;		}						/* ***************** *		 * GETTERS / SETTERS *		 * ***************** */		/* ****** *		 * PUBLIC *		 * ****** */						/* ******* *		 * PRIVATE *		 * ******* */				/**		 * Resize and replace the elements.		 */		override protected function computePositions(e:Event = null):void {			graphics.clear();			var h:int, w:int, pointer:int, px:int, py:int;						if(_height == 0)	_height = CELL_WIDTH;			if(_width == 0)		_width = CELL_WIDTH;						pointer = 0;			if(_splitterType == SplitterType.VERTICAL) {				do {					graphics.lineStyle(0,0,0);					h = CELL_SIZES[pointer % CELL_SIZES.length];					if(py + h > _height) h = _height - py;					graphics.beginFill(BORDER_COLORS[pointer % BORDER_COLORS.length], 1);					graphics.drawRect(1, py, Math.max(_width, CELL_WIDTH), h);					graphics.beginFill(0, SHADOW_ALPHA);					graphics.drawRect(1, py + h - 1, Math.max(_width, CELL_WIDTH), 1);					if(py > 0) {						graphics.lineStyle(0,0,.5);						graphics.moveTo(1,py);						graphics.lineTo(Math.max(_width, CELL_WIDTH) + 1, py);					}					py += h;					pointer ++;				}while(py < _height);								graphics.lineStyle(0,0,.5);				graphics.moveTo(0, 0);				graphics.lineTo(0, _height);				graphics.moveTo(Math.max(_width, CELL_WIDTH) + 1, 0);				graphics.lineTo(Math.max(_width, CELL_WIDTH) + 1, _height);								graphics.lineStyle(0,0,0);				graphics.beginFill(0, SHADOW_ALPHA);				graphics.drawRect(1, 0, 1, _height);							}else if(_splitterType == SplitterType.HORIZONTAL) {				do {					graphics.lineStyle(0,0,0);					w = CELL_SIZES[pointer % CELL_SIZES.length];					if(px + w > _width) w = _width - px;					graphics.beginFill(BORDER_COLORS[pointer % BORDER_COLORS.length], 1);					graphics.drawRect(px, 0, w, Math.max(_height, CELL_WIDTH));					if(px > 0) {						graphics.beginFill(0, SHADOW_ALPHA);						graphics.drawRect(px + 1, 0, 1, Math.max(_height, CELL_WIDTH));						graphics.lineStyle(0,0,.5);						graphics.moveTo(px, 0);						graphics.lineTo(px, Math.max(_height, CELL_WIDTH) + 1);					}					px += w;					pointer ++;				}while(px < _width);								graphics.lineStyle(0,0,.5);				graphics.moveTo(0, -1);				graphics.lineTo(_width, -1);				graphics.moveTo(0, Math.max(_height, CELL_WIDTH) + 0);				graphics.lineTo(_width, Math.max(_height, CELL_WIDTH) + 0);								graphics.lineStyle(0,0,0);				graphics.beginFill(0, SHADOW_ALPHA);				graphics.drawRect(0, Math.max(_height, CELL_WIDTH) - 1, _width, 1);			}		}			}}